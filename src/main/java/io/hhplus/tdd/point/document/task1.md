### ❓ [과제] `point` 패키지의 TODO 와 테스트코드를 작성해주세요.

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.


- 테스트 케이스의 작성 및 작성 이유를 주석으로 작성하도록 합니다.
- 프로젝트 내의 주석을 참고하여 필요한 기능을 작성해주세요.

**요구 사항**
### ℹ️ 과제 필수 사항
- Nest.js 의 경우 Typescript , Spring 의 경우 Kotlin / Java 중 하나로 작성합니다.
  - 프로젝트에 첨부된 설정 파일은 수정하지 않도록 합니다.
- 테스트 케이스의 작성 및 작성 이유를 주석으로 작성하도록 합니다.
- 프로젝트 내의 주석을 참고하여 필요한 기능을 작성해주세요.
- 분산 환경은 고려하지 않습니다.



## Top-Down 으로 방향을 잡고, Bottom-Up 으로 구현에 집중하자.
- 이는 Top-Down 방식으로 설계 및 시나리오를 잡고, Bottom-Up 으로 기능에 대한 코드 구현을 구체화시키면서 문제점을 차례차례 해결해나간다.
즉, "디자인은 Top-Down 으로, 기능은 Bottom-Up 으로"

### 바보 단계 거치기
중간 과정에서의 바보같은 코드를 부끄러워할 필요가 없다. 오히려 처음부터 완벽한 코드를 작성하려고 한다면 개발 속도에도 저하가 발생하며 개발자의 정신건강에도 좋지 않다. 일단 클라이언트 관점에서 기대하는 바를 충족시킬 수 있도록 빠르게 구현한 후, 테스트 케이스가 깨지지 않는지 확인하며 리팩토링을 해나간다.


### 시나리오 구상하기
Given / When / Then 템플릿을 통해 기대 행위에 대한 명세화에 초점을 맞춘다. 
기대 행위에 초점을 맞춰서 생각하면 테스트 메소드 각각의 시나리오를 작성하는 것이 한결 수월해진다.
TDD 의 단위 테스트를 문서화하자.
코드에 구구절절 기록되어 있는 문서는 시간이 지나면서 거짓말을 하게 될 가능성이 높다. 
코드와 문서의 일치성이 보장되지 않기 때문이다. 
하지만, 테스트 코드는 항상 거의 최신을 유지할 가능성이 높으며, 
테스트 코드 자체가 메소드에 대한 사용법이나 예외 등을 담고 있으므로 좋은 샘플 코드로서도 가치가 있다.
테스트 코드가 종이 문서보다 좋은 점은 두 가지인데, 
하나는 일반적으로 테스트 코드는 메소드 당 작성되기 때문에 해당 메소드에 대한 예외 상황을 파악하기 쉽다는 것이다.
그리고, 또 하나는 다른 구현체와의 의존성을 쉽게 파악할 수 있다는 것이다. 
Given / When / Then 구조의 코드를 통해 테스트 코드를 읽는 것만으로 별다른 노력없이 의존성이 파악되는 경우가 많다. 
(물론 가독성이 확보된 테스트 코드에 해당되는 이야기일 것이다.)







# 정리
- 성공 케이스 보다는 실패 케이스에 초점
- 정보를 생성할 수 없는 경우에 집중!
- 정보를 생성할 수 없는 에러 케이스들은 어떤 것이 있을까 생각하면, 데이터베이스에서 Schema를 강제 한다거나 타입, 꼴을 강제한다 거나 하는 것들로 이해해볼 수 있습니다.
- ex. 다음과 같은 경우 '결제 요청'이 불가능하다. (인증 실패,결제 승인,재고 부족,구매불가상품,인가 실패,카드사 점검 시간,카드사 처리 실패,카드가 유효하지 않은 경우 결제 승인 실패,카드의 금액이 부족한 경우 결제 승인 실패)
- 모든 코드를 테스트 가능하게 구현하는 것을 목표로 진행합니다.
- 모든 테스트 케이스가 성공했다는 것은 목표한 기능이 완성되었다는 것을 의미합니다.
- 테스트 커버리지 100% 가 아니라, 정확히 기능의 동작을 확인하는 테스트를 작성해 주세요.
- 주요 기능에서 private 접근자, 객체간의 강결합 같이 테스트 불가능한 코드는 가능한 한 지양하는 것이 좋습니다.
- #1) 기능 구현을 원하는 요구사항을 검증하는 테스트 추가
- #2) 테스트를 만족하도록 기능 구현
>> 이 때, 테스트는 한번에 많은 Scope 를 잡지 않는다. 이는 불필요한 개발 생산성 저하로 이어진다.\
>> 이 시점에서 우리가 몇 배의 시간을 더 투자한다고 해서 테스트 커버리지 100% 를 달성할 수는 없다.\
- #3) 구현된 기능에 대한 리팩토링 ( 인터페이스 구성, 코드클리닝 등 코드 베이스 정리 )
- 단순히 테스트 커버리지 100% 를 목표하기보다 기능에 대해 유의미한 테스트케이스를 고민하고 작성해보세요.
