# API
- API - `PointController` : 포인트 api 
- PATCH  `/point/{id}/charge` : 포인트를 충전한다. 
- PATCH `/point/{id}/use` : 포인트를 사용한다. 
- GET `/point/{id}` : 포인트를 조회한다. 
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.

# 요구사항
- 사용자는 포인트를 충전할수 있습니다.
- 사용자는 포인트를 사용할수 있습니다.
- 사용자는 포인트를 조회할수 있습니다.
- 사용자는 포인트 내역을 조회할수 있습니다. 
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다. 
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

# 테스트케이스 컨벤션
- DisPlayName에 성공테스트-,실패테스트-, 이렇게 시작하기,-뒤에는 행위적기
- 테스트케이스 작성적기 : 테스트 케이스 메소드 위의 주석으로 이 테스트를 간단하게 정의하기
- 테스트케이스 작성이유적기 : 테스트케이스 작성이유를 주석에 적기
- method 행위 검증 - 메소드 호출이 되었는지 확인
- mock 데이터 검증 - 데이터베이스가 이러한 데이터를 리턴하면 어떻게 할것인지 확인
- ArgumentCaptor 인자값 검증 - 의도한 대로 동작하면 이러한 인자값이 들어오는지 확인


# 끄적끄적 테스트시나리오-단위테스트
- [x] 성공테스트-최초회원의 포인트는 0으로 설정됩니다.
---
- [x] 성공테스트-포인트충전:사용자는 포인트를 충전할수있습니다
- [ ] 실패테스트-포인트충전실패(음수포인트충전시도)
- [ ] 실패테스트-포인트충전실패(사용자가 null인데 충전시도)
---
- [x] 성공테스트-포인트사용:사용자는 포인트를 사용할수있습니다 
- [ ] 실패테스트-포인트사용실패(존재하지않는 아이디로 포인트 사용시도)
- [x] 실패테스트-포인트사용실패(포인트부족)-사용자는 포인트가 부족하여 사용에 실패합니다
  - 잔고가 부족할 경우 Illegal 던져주기
---
- [x] 성공테스트-포인트조회:사용자는 포인트를 조회할수있습니다
- [ ] 실패테스트-포인트조회실패(존재하지않는 아이디로 포인트조회)
---
- [x] 성공테스트-포인트사용내역조회-사용자는 포인트사용내역을 조회할수있습니다
---
- 실패테스트-포인트 충전/사용하다가 에러가발생했을경우 실패한데이터를 담기위해 실패데이터백업과 로그를 남긴다.
## 에러가 발생했을때 GWT

- 포인트를 충전/사용하다가 실패한데이터를 담기위해서 PointFailedEvent라는 클래스를 생성




# 끄적끄적 테스트시나리오-통합테스트
- [x] 성공테스트-동시성포인트충전:다수의 포인트충전요청시 정확한 포인트증가를 검증합니다.
- [ ] 성공테스트-동시성포인트사용:다수의 포인트사용요청시 정확한 포인트사용을 검증합니다.

# 동시성해결고민하기
- 1인당 충전은 하루에 10번
- 동시에 할수 있는 요청은 20개
- set은 값을 유니크하게 저장할수있는 자료구조
- 충전중인게 10개이면 딜레이주고 그다음 오세요
- 너무 많은요청이 있다
- 줄 세운다. 10개정도. 그 다음 하나하나씩 비동기적으로 요청들을 계속 받으면 되나?





### 주의사항
- 프로젝트에 첨부된 설정 파일은 수정하지 않도록 합니다.
- 테스트 케이스의 작성 및 작성 이유를 주석으로 작성하도록 합니다.
- 프로젝트 내의 주석을 참고하여 필요한 기능을 작성해주세요.
- 분산 환경은 고려하지 않습니다

# 테스트코드 작성하기
1. 설계 및 시나리오를 잡고 기능에 대한 코드 구현을 구체화
2. 기능 구현을 원하는 요구사항을 검증하는 테스트 추가
3. 테스트를 만족하도록 기능 구현-간단하게 작성했다가 리팩토링하면서 발전시키기
    - 이 때, 테스트는 한번에 많은 Scope 를 잡지 않는다. 이는 불필요한 개발 생산성 저하로 이어진다.
    - 이 시점에서 우리가 몇 배의 시간을 더 투자한다고 해서 테스트 커버리지 100% 를 달성할 수는 없다.
4. 시나리오 구상하기 - Given / when / then 템플릿을 통해 기대 행위에 대한 명세화 초점맞추기
5. 구현된 기능에 대한 리팩토링 ( 인터페이스 구성, 코드클리닝 등 코드 베이스 정리 )
- 기대 행위에 초점을 맞춰서 생각하면 테스트 메소드 각각의 시나리오를 작성하면 수월해진다.
- 성공 케이스 보다는 실패 케이스에 초점
- 정보를 생성할 수 없는 경우에 집중!
- 정보를 생성할 수 없는 에러 케이스들은 어떤 것이 있을까 생각하면, 데이터베이스에서 Schema를 강제 한다거나 타입, 꼴을 강제한다 거나 하는 것들로 이해해볼 수 있습니다. ex. 다음과 같은 경우 '결제 요청'이 불가능하다. (인증 실패,결제 승인,재고 부족,구매불가상품,인가 실패,카드사 점검 시간,카드사 처리 실패,카드가 유효하지 않은 경우 결제 승인 실패,카드의 금액이 부족한 경우 결제 승인 실패
- 모든 코드를 테스트 가능하게 구현하는 것을 목표로 진행합니다.
- 모든 테스트 케이스가 성공했다는 것은 목표한 기능이 완성되었다는 것을 의미합니다.
- 테스트 커버리지 100% 가 아니라, 정확히 기능의 동작을 확인하는 테스트를 작성해 주세요.
- 주요 기능에서 private 접근자, 객체간의 강결합 같이 테스트 불가능한 코드는 가능한 한 지양하는 것이 좋습니다.
- 단순히 테스트 커버리지 100% 를 목표하기보다 기능에 대해 유의미한 테스트케이스를 고민하고 작성하기
### Mock TEST 검증하기
- method 행위 검증 - 메소드 호출이 되었는지 확인하기
- mock 데이터 검증 - 데이터베이스가 이러한 데이터를 리턴하면 어떻게 할것인지 확인하기
- ArgumentCaptor 인자값 검증 - 의도한 대로 동작하면 이러한 인자값이 들어오는지 확인하기