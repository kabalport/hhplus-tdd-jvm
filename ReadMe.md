# API
- API - `PointController` : 포인트 api 
- PATCH  `/point/{id}/charge` : 포인트를 충전한다. 
- PATCH `/point/{id}/use` : 포인트를 사용한다. 
- GET `/point/{id}` : 포인트를 조회한다. 
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.

### 주의사항
- 프로젝트에 첨부된 설정 파일은 수정하지 않도록 합니다.
- 테스트 케이스의 작성 및 작성 이유를 주석으로 작성하도록 합니다.
- 프로젝트 내의 주석을 참고하여 필요한 기능을 작성해주세요.
- 분산 환경은 고려하지 않습니다

# 요구사항
- 사용자는 포인트를 충전할수 있습니다.
- 사용자는 포인트를 사용할수 있습니다.
- 사용자는 포인트를 조회할수 있습니다.
- 사용자는 포인트 내역을 조회할수 있습니다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

# 정리

## 테스트코드 작성하기 기준
1. 설계 및 시나리오를 잡고 기능에 대한 코드 구현을 구체화
2. 기능 구현을 원하는 요구사항을 검증하는 테스트 추가
3. 테스트를 만족하도록 기능 구현-간단하게 작성했다가 리팩토링하면서 발전시키기
    - 이 때, 테스트는 한번에 많은 Scope 를 잡지 않는다. 이는 불필요한 개발 생산성 저하로 이어진다.
    - 이 시점에서 우리가 몇 배의 시간을 더 투자한다고 해서 테스트 커버리지 100% 를 달성할 수는 없다.
4. 시나리오 구상하기 - Given / when / then 템플릿을 통해 기대 행위에 대한 명세화 초점맞추기
5. 구현된 기능에 대한 리팩토링 ( 인터페이스 구성, 코드클리닝 등 코드 베이스 정리 )
- 기대 행위에 초점을 맞춰서 생각하면 테스트 메소드 각각의 시나리오를 작성하면 수월해진다.
- 성공 케이스 보다는 실패 케이스에 초점
- 정보를 생성할 수 없는 경우에 집중!
- 정보를 생성할 수 없는 에러 케이스들은 어떤 것이 있을까 생각하면, 데이터베이스에서 Schema를 강제 한다거나 타입, 꼴을 강제한다 거나 하는 것들로 이해해볼 수 있습니다. ex. 다음과 같은 경우 '결제 요청'이 불가능하다. (인증 실패,결제 승인,재고 부족,구매불가상품,인가 실패,카드사 점검 시간,카드사 처리 실패,카드가 유효하지 않은 경우 결제 승인 실패,카드의 금액이 부족한 경우 결제 승인 실패
- 모든 코드를 테스트 가능하게 구현하는 것을 목표로 진행합니다.
- 모든 테스트 케이스가 성공했다는 것은 목표한 기능이 완성되었다는 것을 의미합니다.
- 테스트 커버리지 100% 가 아니라, 정확히 기능의 동작을 확인하는 테스트를 작성해 주세요.
- 주요 기능에서 private 접근자, 객체간의 강결합 같이 테스트 불가능한 코드는 가능한 한 지양하는 것이 좋습니다.
- 단순히 테스트 커버리지 100% 를 목표하기보다 기능에 대해 유의미한 테스트케이스를 고민하고 작성하기

## 컨벤션 기준 - 정리전
### [로깅 컨트롤러 컨벤션]
통합테스트는 실패했을때는 로깅을 제대로하고있는지 검증하는 실패케이스 정도???
통합테스트 돌리다가 어떤사람이 진짜 찐디비연결해서 어플리케이션을 돌리고 결제오류내보면???
HTTP 요청 처리 중 발생하는 예외에 대해 사용자에게 보다 상세한 피드백을 제공하고 싶을 때.
요청 컨텍스트(예: 요청 경로, 사용자 세션 정보 등)를 로그에 포함시켜 문제의 원인 분석을 용이하게 하고 싶을 때.
### [로깅 서비스 컨벤션]
서비스 레벨에서의 예외 처리 및 로깅은 비즈니스 로직과 관련된 오류를 기록하고자 할 때 더 적합할 수 있습니다.
컨트롤러 레벨에서의 예외 처리 및 로깅은 사용자 요청 처리와 관련된 컨텍스트 정보를 로그에 포함시키고 사용자에게 보다 명확한 피드백을 제공하고자 할 때 더 유리합니다.
이 과정에서 주의해야 할 점은, 통합 테스트는 단위 테스트보다 실행 속도가 느리고, 외부 시스템에 대한 의존성으로 인해 테스트 환경 구성이 복잡해질 수 있다는 것입니다. 따라서, 통합 테스트에서는 시스템의 핵심적인 동작이나 비즈니스 로직의 흐름을 중점적으로 검증하는 것이 바람직하며, 세부적인 실패 처리 로직 같은 경우는 단위 테스트에서 보다 상세히 다루는 것이 효율적일 수 있습니다.
로깅 확인: 실패 이벤트가 로그로도 기록된다면, 로그 내용을 통해 실패 이벤트가 올바르게 기록되었는지 간접적으로 확인할 수 있습니다.
통합테스트에 실패케이스를 만들것인가
단위테스트에 실패케이스 아주많이
통합테스트는 성공케이스를 아주많이?
로깅 확인: 실패 이벤트가 로그로도 기록된다면, 로그 내용을 통해 실패 이벤트가 올바르게 기록되었는지 간접적으로 확인할 수 있습니다.
# 테스트케이스 컨벤션
- DisPlayName에 성공테스트-,실패테스트-, 이렇게 시작하기,-뒤에는 행위적기
- 테스트케이스 작성적기 : 테스트 케이스 메소드 위의 주석으로 이 테스트를 간단하게 정의하기
- 테스트케이스 작성이유적기 : 테스트케이스 작성이유를 주석에 적기
- method 행위 검증 - 메소드 호출이 되었는지 확인
- mock 데이터 검증 - 데이터베이스가 이러한 데이터를 리턴하면 어떻게 할것인지 확인
- ArgumentCaptor 인자값 검증 - 의도한 대로 동작하면 이러한 인자값이 들어오는지 확인
## Mock Test 컨벤션
- method 행위 검증 - 메소드 호출이 되었는지 확인하기
- mock 데이터 검증 - 데이터베이스가 이러한 데이터를 리턴하면 어떻게 할것인지 확인하기
- ArgumentCaptor 인자값 검증 - 의도한 대로 동작하면 이러한 인자값이 들어오는지 확인하기
## Integration Test

# 끄적끄적 테스트시나리오-단위테스트
- [x] 성공테스트-최초회원의 포인트는 0으로 설정됩니다.
- [x] 실패테스트-포인트충전시 실패한데이터를 실패데이터백업을 합니다.
---
- [x] 성공테스트-포인트충전:사용자는 포인트를 충전할수있습니다
- [x] 실패테스트-포인트충전실패(음수포인트충전시도)

---
- [x] 성공테스트-포인트사용:사용자는 포인트를 사용할수있습니다 
- [x] 실패테스트-포인트사용실패(존재하지않는아이디로포인트사용)
- [x] 실패테스트-포인트사용실패(포인트부족)-사용자는 포인트가 부족하여 사용에 실패합니다
  - 잔고가 부족할 경우 PointException message 던져주기
---
- [x] 성공테스트-포인트조회:사용자는 포인트를 조회할수있습니다
- [x] 실패테스트-포인트조회실패(존재하지않는아이디로포인트조회)
---
- [x] 성공테스트-포인트사용내역조회-사용자는 포인트사용내역을 조회할수있습니다
---



# 끄적끄적 테스트시나리오-통합테스트
- [x] 성공테스트-동시성포인트충전-다수의_포인트충전요청시_정확한_포인트증가를_검증합니다
- [x] 성공테스트-동시성포인트사용-다수의_포인트사용요청시_정확한포인트사용을_검증합니다
- [x] 성공테스트-동시성포인트사용-다수의_포인트사용과_충전요청시_정확한_포인트사용을_검증합니다


# 동시성해결고민하기
- 1인당 충전은 하루에 10번
- 동시에 할수 있는 요청은 20개
- set은 값을 유니크하게 저장할수있는 자료구조
- 충전중인게 10개이면 딜레이주고 그다음 오세요
- 너무 많은요청이 있다
- 줄 세운다. 10개정도. 그 다음 하나하나씩 비동기적으로 요청들을 계속 받으면 되나?

테스트할때 100건도 병렬처리 느린거보고 syncronize 존나 편한데 이거 좋은방법아닌것같음
동시성처리 아이디어
작업큐를 만들어서 스케줄링한다.
인계영역에 Lock을 걸어 동시에 하나의 작업만 쓰기 작업을 수행할수 있도록 제한한다.
비동기처리
순서가 보장이 되는가? 안되는가?

어노테이션Transactional 동기성제어가 되나
동시성테스트를 할때 하나의 테스트에
한번 충천


[정리전]





한

이전에는 디비연결은 이미 해놓았으니 api호출시켜보면서 작업을 했는데
도메인클래스만 던져주고 개발을 해보니 하나하나 전부의심됨 
경험이 없어서 손발이 더 고생하는느낌이기도함

도메인에서 할수 있는일은 도메인에서 끝내자-뭐 그 id값 랜덤처리 등등



synchronized
ConcurrentHashMap
RentrantLock
어노테이션Transactional 동기성제어가 되나
제네릭



# 리팩토링
- 테스트코드작성시 스레드풀은 몇으로 테스트해야됨??
- 테이블의 아이디의 커서가 잘 작동하는지테스트
- fixture만들어서 성공객체,실패객체들 만들어서 테스트객체 재사용하게 리팩토링하기

- 유스케이스다이어그램
- 클래스다이어그램
- 시퀀스다이어그램
- Spring REST Docs api명세서 사용해보기
  [https://helloworld.kurly.com/blog/spring-rest-docs-guide/]
- 제네릭,Optional,Stream
- 전체적인 메서드들 리팩토링하기
- 가독성 좋은 테스트코드를 만들고싶다.
  목테스트-성공 테스크코드클래스,목테스트-실패 태스트코드클래스 따로 두는게 좋을듯하게보인다.->왜냐하면 하나의 Mock테스트 모았더니 복잡하다.
- 공통코드정의 enum 해야되나?
